?cbmc_clause : requires_clause | ensures_clause | assigns_clause

requires_clause : "__CPROVER_requires" "(" bool_expr ")"
ensures_clause : "__CPROVER_ensures" "(" bool_expr ")"
assigns_clause : "__CPROVER_assigns" "(" assigns_content ")"

?bool_expr : expr

// ---------- Logical precedence ----------
?expr: logical_or

?logical_or: logical_and
           | logical_or "||" logical_and   -> or_op

?logical_and: equality
             | logical_and "&&" equality   -> and_op

// ---------- Equality and relational ops ----------
?equality: relational
         | equality "==" relational        -> eq_op
         | equality "!=" relational        -> neq_op

?relational: additive
            | relational "<" additive      -> lt_op
            | relational "<=" additive     -> le_op
            | relational ">" additive      -> gt_op
            | relational ">=" additive     -> ge_op

// ---------- Arithmetic ----------
?additive: multiplicative
          | additive "+" multiplicative    -> add_op
          | additive "-" multiplicative    -> sub_op

?multiplicative: unary
                | multiplicative "*" unary -> mul_op
                | multiplicative "/" unary -> div_op
                | multiplicative "%" unary -> mod_op

// ---------- Unary (prefix ops) ----------
?unary: postfix
      | "!" unary                          -> not_op
      | "&" unary                          -> addr_op
      | "*" unary                          -> deref_op
      | "-" unary                          -> neg_op
      | "+" unary                          -> pos_op

// ---------- Postfix (member, call, index) ----------
?postfix: primary
        | postfix "." NAME                 -> member_op
        | postfix "->" NAME                -> ptr_member_op
        | postfix "[" expr "]"             -> index_op
        | postfix "(" [arg_list] ")"       -> call_op

?arg_list: expr ("," expr)*

// ---------- Primary values ----------
?primary: quantifier_expr
        | NAME
        | NUMBER
        | BOOL
        | STRING
        | "(" expr ")"

// --------- Assigns Contents -------------------------

?assigns_content:                             -> assigns_empty
                | expr_list                   -> assigns_unconditional
                | bool_expr ":" expr_list     -> assigns_conditional

expr_list: expr ("," expr)*

// ---------- Quantifiers ------------
?quantifier_expr : forall_expr | exists_expr
forall_expr : "__CPROVER_forall" "{" quantifier_decl ";" "(" bool_expr ")" "==>" bool_expr "}"
exists_expr : "__CPROVER_exists" "{" quantifier_decl ";" "(" bool_expr ")" "&&" bool_expr "}"

quantifier_decl : typ NAME


// ---------- Types ----------
// Token for builtin type keywords (prevents them being lexed as NAME)
TYPE_KW: "int" | "unsigned" | "signed" | "bool" | "char" | "float" | "double" | "long" | "short"

// A type is either a builtin keyword or a typedef NAME
typ: TYPE_KW | NAME

// ---------- Tokens ----------
BOOL: "1" | "0"

NAME: /[A-Za-z_][A-Za-z0-9_]*/

STRING: /"[^"]*"/

NUMBER: /[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?/
%import common.WS_INLINE
%import common.WS
%ignore WS_INLINE
%ignore WS